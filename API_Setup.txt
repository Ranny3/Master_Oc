import sys
import os
from scipy.signal import argrelextrema  # usada para encontrar os √≠ndices de m√°ximos e m√≠nimos locais em uma matriz unidimensional
import os
import csv  
import shutil
from sklearn.metrics import mean_squared_error   #  usada para calcular o erro quadr√°tico m√©dio entre os valores observados e previstos.
import math
import matplotlib.pyplot as plt
import numpy as np
from scipy import stats
from scipy import interpolate

sys.path.append('../')                              # Adiciona o diret√≥rio pai do diret√≥rio atual ao caminho de pesquisa do Python. Isso permite que o Python encontre m√≥dulos e pacotes localizados nesse diret√≥rio
from codes.datafiles_list import datafiles_list

def datafiles_list():
    list_of_files = []
    list_of_files.append('../data/data_example.txt')
    return (list_of_files)

#B:\Cassie-core_Larissa_2023\01_dados_brutos\Dados Gold Coast\data

#Se quiser importar mais de um arquivo, al√©m do data_example
import os

def datafiles_list(directory='../data'):
    list_of_files = []
    for filename in os.listdir(directory):
        if os.path.isfile(os.path.join(directory, filename)):
            list_of_files.append(os.path.join(directory, filename))
    return list_of_files

                                                            --
from codes.list_of_transects import list_of_transects        # retorna uma lista contendo os nomes √∫nicos dos transectos

import numpy as np

def list_of_transects(path):
    try:                                             #  Inicia um bloco de c√≥digo onde exce√ß√µes ser√£o tratadas.
        try:
            f = open(path, 'r', encoding='utf-16')    #  Abre o arquivo especificado pelo caminho `path` em modo de leitura (`'r'`) e com codifica√ß√£o `'utf-16'`.
            content = f.readlines()
        except:
            f = open(path, 'r')
            content = f.readlines()
        transect = []
        for line in content:    #  Itera sobre todas as linhas do conte√∫do do arquivo.
            line_formatted = line.replace('\n',' ').replace('      ',' ').replace('    ',' ').replace('   ',' ').replace('  ',' ').split(' ')  # Remove espa√ßos extras e quebras de linha da linha atual e divide a linha em uma lista de palavras usando o espa√ßo como separador
            if '0' in line_formatted[0]:     # Verifica se a primeira palavra da linha cont√©m o caractere '0'
                try:
                    transect.append(line_formatted[6])     # Adiciona o line_formatted aos transectos.
                except:
                    pass
       
        transects_list=np.unique(transect)    # Remove duplicatas
        return(transects_list)
    except:
        print(path)

                                                                    --
from codes.import_transects import import_transects    # Definem fun√ß√µes para listar arquivos em um diret√≥rio e fornecem op√ß√µes para especificar um diret√≥rio diferente ou usar um diret√≥rio padr√£o

from codes.convertingCoordinates import convertingCoordinates
import matplotlib.pyplot as plt
from codes.distanceFromCoastline import distance_from_coastline
import numpy as np

def import_transects(path, transect_name):
    try: 
        try:
            f = open(path, 'r', encoding='utf-16')
            content = f.readlines()
        except:
            f = open(path, 'r')
            content = f.readlines()
        transect = []
        id = []
        mga_lat = []
        mga_lon = []
        bat = [] 
        type = []
        date = []
        test = np.array  # Inicializa listas vazias para armazenar as informa√ß√µes do transecto.
        for line in content:

            line_formatted = line.replace('\n',' ').replace('      ',' ').replace('    ',' ').replace('   ',' ').replace('  ',' ').split(' ')
            if '0' in line_formatted[0]:
                if transect_name == line_formatted[6]:
                    try:
                        test = np.append(test, line_formatted[0])    #  Adiciona o primeiro elemento da lista formatada da linha √† vari√°vel `test`
                        id.append(line_formatted[0])
                        mga_lat.append(line_formatted[1])
                        mga_lon.append(line_formatted[2])
                        bat.append(line_formatted[3])
                        type.append(line_formatted[4])
                        date.append(line_formatted[5])
                        transect.append(line_formatted[6])
                    except:
                        pass
        id = list(map(int, id))      
        bat = list(map(float, bat)) # Transforma as vari√°veis de n¬∞ inteiros pra float (decimais)
        mga_lat = list(map(float, mga_lat)) 
        mga_lon = list(map(float, mga_lon))

        lat,lon = convertingCoordinates(mga_lat,mga_lon)
        all_data = id,transect,lat,lon,bat,date
        data_array = np.array(all_data)
        
        distance=distance_from_coastline(data_array[2],data_array[3],data_array[4])
        bathymetry=all_data[4]
        transect_date=all_data[5]

        return(distance,bathymetry,transect_date)
    except:
        pass
                                            --

from codes.bar_profile_equations import barProfilefunction

import numpy as np
from math import e    # representa a base do logaritmo natural
import matplotlib.pyplot as plt

def barProfilefunction(xc_option, xt, xc, xf, h0, hinf=[], xinf=[], last_bar=True):
    
    xm = (xt + xc)/2 # Calcula o ponto m√©dio
    
    #Eq.1 Bruun equation:
    if xc_option ==1:
        hc = 0.106*xc**(2/3) # Parametros granulometria de Gold Coast 

    #Silvester e Hsu equations:
    #Eq.2
    if xc_option == 2:
        hc = 0.111*xc**0.575
    #Eq.3
    if xc_option == 3:
        hc = 0.0225*xc

    #Eq.4
    tanB = hc/(0.6366+(0.436*xc))

    #Eq.5
    he = xt*tanB #falta xt ou he

    #Eq.6
    X=xt
    d = 0.125*X**0.667

    # ### Cabellaria et al.:
    #Eq.7 (ùë• ‚â• ùë• ùë° ),
    ht=d
    x_array=np.array([])
    h_array=np.array([])
    h5_list=[]
    x5_list=[]
    for x in np.arange(0,xt,0.5):
        h=((h0-ht)*(((x-xt)**2)/(xt**2))+ht)
        x_array=np.append(x_array,x)
        h_array=np.append(h_array,-h)
        h5_list.append(-h)
        x5_list.append(x)
    equation5=np.array([h5_list,x5_list])

    #Eq.8 (ùë• ùë° < ùë• ‚â• ùë• ùëö ),
    h6_list=[]
    x6_list=[]
    for x in np.arange(xt,xm,0.5):
        h=((hc-ht)*(((x-xt)**2)/((xm-xt)*(xc-xt)))+ht)
        x_array=np.append(x_array,x)
        h_array=np.append(h_array,-h)
        h6_list.append(-h)
        x6_list.append(x)
    equation6=np.array([h6_list,x6_list])

    #Eq.9 (ùë• ùëö < ùë• ‚â• ùë• ùëê )
    h7_list=[]
    x7_list=[]
    for x in np.arange(xm,xc,0.5):
        h=((hc-ht)*(((x-xc)**2)/((xm-xc)*(xc-xt)))+hc)
        x_array=np.append(x_array,x)
        h_array=np.append(h_array,-h)
        h7_list.append(-h)
        x7_list.append(x)
    equation7=np.array([h7_list,x7_list])

    #Eq.10 (ùë• ùëê < ùë• ‚â• ùë• ùëì ),
    X=xf
    d = 0.125*X**0.667
    hf=d
    h8_list=[]
    x8_list=[]
    for x in np.arange(xc,xf,0.5):
        h=((hf-hc)*(((x-xc)**2)/((xf-xc)**2))+hc)
        h8_list.append(-h)
        x8_list.append(x)
        x_array=np.append(x_array,x)
        h_array=np.append(h_array,-h)
    equation8=np.array([h8_list,x8_list])

    #Eq.11 (ùë• ùëì ‚â• ùë•),
    if last_bar == True:

        hinf=abs(hinf)
        h9_list=[]
        x9_list=[]
        for x in np.arange(xf,xinf, 0.5):
            
            A= -2 * ((x - xf) * (hf - hc)) / ((xf - xc) * (hinf - hf))
            B = e**(A)
            C = 1-B
            D = (hinf - hf) * C
            E = D + hf
            h9_list.append(-E)
            x9_list.append(x)
            x_array=np.append(x_array,x)
            h_array=np.append(h_array,-E)
        equation9=np.array([h9_list,x9_list])

    return x_array, h_array
                                                            --
from codes.transect_average import transect_average 

import statistics
import numpy as np

def transect_average(distance,bat): # Defini a fun√ß√£o que aceita dois par√¢metros
    bat_means = [] # Inicializa uma lista vazia
    range_media = range(-100, 1000, 10) # Define uma faixa de -100 a 990 com um passo de 10 e armazena isso na vari√°vel, Esta faixa ser√° usada para calcular as m√©dias das batimetrias em intervalos espec√≠ficos de dist√¢ncia.

    meanDistance = []
    meanBat = []

    for i in range(1,len(range_media)): #????????????? completado com a l√≥gica necess√°ria para calcular as m√©dias das batimetrias nos intervalos espec√≠ficos de dist√¢ncia.

                                                            ----
my_list_of_paths = datafiles_list()
my_list_of_transects = list_of_transects(my_list_of_paths[0])
path = my_list_of_paths[0] 
transect_name= my_list_of_transects[0]
                                                            ----

# √â importante observar que as batimetrias m√°ximas e m√≠nimas est√£o sendo calculadas com base nas batimetrias m√©dias calculadas em intervalos espec√≠ficos de dist√¢ncia. Este trecho de c√≥digo parece estar relacionado √† an√°lise e visualiza√ß√£o dos dados de batimetria de um transecto espec√≠fico.

distance,bathymetry,transect_date = import_transects(path,transect_name)
unique_values,batMeans = transect_average(distance,np.array(bathymetry)) # Chama a fun√ß√£o  para calcular a m√©dia da batimetria em intervalos espec√≠ficos de dist√¢ncia. Os resultados s√£o armazenadas nas vari√°veis iniciais
max_bat = (np.array(batMeans)[argrelextrema(np.array(batMeans), np.greater)[0]])
max_dist = (np.array(unique_values)[argrelextrema(np.array(batMeans), np.greater)[0]])
min_bat = (np.array(batMeans)[argrelextrema(np.array(batMeans), np.less)[0]])
min_dist = (np.array(unique_values)[argrelextrema(np.array(batMeans), np.less)[0]])
plt.figure()
plt.plot(distance,bathymetry)
plt.title(f'{max_dist,min_dist}')


                                                            ----
xc_option, xt, xc, xf, h0 = (2, 60,120,180,0.1) # Define os valores dos par√¢metros para calcular o perfil da barra
hinf=-14
xinf=1300

distance_equations, bat_equations = barProfilefunction(xc_option, xt, xc, xf, h0, hinf, xinf, last_bar=False)
plt.plot(distance_equations, bat_equations)
plt.plot(distance,bathymetry)
plt.title(**)

                                                            -------------------------------------------------------
f = interpolate.interp1d(distance, bathymetry,'cubic')
bat_obs_interp = f(distance_equations)   # use interpolation function returned by `interp1d`

transect_std =[]
transect_std = (np.std([bat_obs_interp,bat_equations]))
MSE = mean_squared_error(bat_obs_interp, bat_equations)
RMSE = math.sqrt(MSE)

result = stats.linregress(bat_obs_interp, bat_equations)
fig, ax = plt.subplots(figsize = (14, 7))

plt.plot(distance_equations,bat_equations, label = 'Batimetria calculada')
plt.plot(distance,bathymetry, label='Batimetria observada')
plt.legend()
pltxlim(-10,200)
plt.y.title(f'{transect_name} -'    f' { transect_date[0]}     RMSE:' f'{RMSE:.4f}     STD:' f'{np.mean(transect_std):.4f}   r2: {(result.rvalue**2):.4f}' )
ax.set_ylabel('Profundidade (m)')
ax.set_xlabel('Dist√¢ncia da costa (m)')
plt.lim(-5,1)
 sys.path.append('B:/Cassie-core_Larissa_2023/02_trabalho/05_resultados')
 os.chdir('B:/Cassie-core_Larissa_2023/02_trabalho/05_resultados'')
 filename = (f'{transect_name}' + '_' + f'{transect_date[0]}.jpg')
 plt.savefig(filename)


--------------------------------------------------------------------
# header = ['transect_name', 'transect_date' ,'dist_equations', 'bat_equations', 'bat_obs_interp']

# with open(filename.replace('jpg','csv'), 'w', encoding='UTF8') as f:
#     writer = csv.writer(f)
#     writer.writerow(header)
#     for i in range(len(distance_equations)):
#         writer.writerow([transect_name, transect_date[0], distance_equations[i],bat_equations[i],bat_obs_interp[i]])


# original = r'../setups/setup1bar.ipynb'
# target = r'../setups/'f'{transect_name}' + '_' + f'{transect_date[0]}.ipynb'
# shutil.copyfile(original, target)
